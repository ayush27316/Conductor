package com.conductor.core.security.fiber;

import com.conductor.core.model.ExternalIdentityProvider;
import com.conductor.core.model.Resource;
import com.conductor.core.model.ResourceType;
import com.conductor.core.model.application.Application;
import com.conductor.core.model.event.Event;
import com.conductor.core.model.org.Organization;
import com.conductor.core.util.Pair;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.UUID;

/**
 * Fiber provides external identity to all {@link Resource}'s within
 * conductor. ID generation is entity aware and helps to easily
 * verify if two entities are associated based just on their external identities.
 *
 */

/**
 * a global resource secret key
 *
 * organization id will just be its name
 * but if we can reduce the size of the id using a hash or sothin
 *
 * 1) event id will be organizaiton_name.event_name.sign
 * generated by F(pk, organizaiton_name, event_name)
 *
 * 2)for all event'child id:  organizaiton_name.event_name.child_id.sign
 *
 * for child we can first produce a random uui then hash it such that eveyrhting is 8bytes
 * and signature is 16 bytes. total 3*8 + 16 = 42 bytes
 * When a request comes in for a resrouce with id of either an evnet or its children
 * we can verify that it belongs to the parent it claims to be using pk
 *
 *
 */
@Component
public class FiberIdentityProvider implements ExternalIdentityProvider {

    private static byte[] key = """
            asdfhads9f67as98dfyaisudhfa98s67dfy89a
            ishudfuays89dfyasi8df7asdf87987g98a7sg
            986a89sdf7y
            """.getBytes();

    public static byte[] sign16Bytes(String value)
            throws NoSuchAlgorithmException, InvalidKeyException {
        Mac mac = Mac.getInstance("HmacSHA256");
        SecretKeySpec secretKey = new SecretKeySpec(key, "HmacSHA256");
        mac.init(secretKey);

        byte[] fullHmac = mac.doFinal(value.getBytes());

        // Truncate to first 16 bytes
        return Arrays.copyOf(fullHmac, 16);
    }

    public static boolean verify(String value, String signature)
            throws NoSuchAlgorithmException, InvalidKeyException {
        byte[] expected = sign16Bytes(value);

        // Use MessageDigest.isEqual() for constant-time comparison
        return MessageDigest.isEqual(expected, hexToBytes(signature));
    }

    // Helper method to convert hex string to byte array
    public static byte[] hexToBytes(String hex) {
        int len = hex.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)
                    + Character.digit(hex.charAt(i+1), 16));
        }
        return data;
    }

    // Helper method to convert byte array to hex string
    public static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }

    /**
     * Hash the input argument to a 64-bit value.
     * @param input string to hash
     * @return the hash value as string
     */
    public static String fnv1aHash64(String input) {
        final long FNV_OFFSET_BASIS = 0xcbf29ce484222325L;
        final long FNV_PRIME = 0x100000001b3L;

        long hash = FNV_OFFSET_BASIS;
        byte[] bytes = input.getBytes(StandardCharsets.UTF_8);

        for (byte b : bytes) {
            hash ^= (b & 0xFF);
            hash *= FNV_PRIME;
        }

        return Long.toString(hash);
    }

    @Override
    public String generateId(Resource resource) {
        return switch (resource.getResourceType()){
            case ORGANIZATION -> fnv1aHash64(Resource.safeCast(Organization.class, resource).get().getName());
            case EVENT -> generateIdForEvent(Resource.safeCast(Event.class, resource).get());
            case APPLICATION -> generateIdForApplication(Resource.safeCast(Application.class, resource).get());
            default -> fnv1aHash64(UUID.randomUUID().toString());
        };
    }

    private String generateIdForApplication(Application application) {
        //find the organization external id, generate a hash of events name
        //then org_id.event_name_has.sign is id of event
        String applicationHash = fnv1aHash64(UUID.randomUUID().toString());

        if(application.getTargetResource().getResourceType().equals(ResourceType.ORGANIZATION)){

            //in this case application acts like its own root in fiber

            //new hash for this application based of a random uiid
//            String organizationHash = application.getTargetResource().getExternalId();
//
//            String value = organizationHash + '.' + applicationHash;
//
//            byte[] sign;
//            try {
//                 sign = sign16Bytes(value);
//            } catch (NoSuchAlgorithmException e) {
//                throw new RuntimeException(e);
//            } catch (InvalidKeyException e) {
//                throw new RuntimeException(e);
//            }
            return  applicationHash;
        }

        if (application.getTargetResource().getResourceType().equals(ResourceType.EVENT))
        {
            Event event = Resource.safeCast(Event.class, application.getTargetResource()).get();
            String organizationExternalId = event.getOrganization().getExternalId();


            String value = organizationExternalId + '.' + event.getExternalId() + '.' + applicationHash;
            byte[] sign;
            try {
                sign = sign16Bytes(value);
            } catch (NoSuchAlgorithmException e) {
                throw new RuntimeException(e);
            } catch (InvalidKeyException e) {
                throw new RuntimeException(e);
            }

            return  value + '.' + bytesToHex(sign);
        }
        return null;

    }

    private String generateIdForEvent(Event event) {
        //find the organization external id, generate a hash of events name
        //then org_id.event_name_has.sign is id of event
        String organizationHash = event.getOrganization().getExternalId();

        String eventHash = fnv1aHash64(event.getName());

        String value = organizationHash + '.' + eventHash;
        byte[] sign;
        try {
            sign = sign16Bytes(value);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        } catch (InvalidKeyException e) {
            throw new RuntimeException(e);
        }
        return  value + "." + bytesToHex(sign);
    }

    public String getRootResource(ResourceType type, String resourceExternalId){
        int dotIndex = resourceExternalId.indexOf(".");
        String rootId;

        if (dotIndex != -1) {
            rootId = resourceExternalId.substring(0, dotIndex);
        } else {
            // no dot found, return the whole string
            rootId = resourceExternalId;
        }
        return rootId;
    }

    public Pair<String,String> getApplicationParent(String applicationExternalId){
        String[] ids = applicationExternalId.split(".");
        return Pair.of(ids[0], ids[1]);
    }
}
